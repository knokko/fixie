package fixie.generator.area

import fixie.generator.number.FloatType
import java.io.PrintWriter
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

class AreaClassGenerator(
        private val writer: PrintWriter,
        private val area: AreaClass,
        private val packageName: String
) {

    fun generate() {
        generateClassPrefix()
        generateToDouble()
        generateToString()
        generateArithmetic()
        generateCompanionObject()
        writer.println("}")
        generateExtensionFunctions()
        generateMathFunctions()
    }

    private fun generateClassPrefix() {
        val currentTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm"))
        writer.println("// Generated by fixie at $currentTime")
        writer.println("package $packageName")
        writer.println()
        for (functionName in arrayOf("abs", "max", "min")) writer.println("import kotlin.math.$functionName")
        if (area.displacementClassName != null) writer.println("import kotlin.math.sqrt")
        writer.println()
        writer.println("@JvmInline")
        writer.println("value class ${area.className} internal constructor(val value: ${area.floatType.typeName}) " +
                ": Comparable<${area.className}> {")
    }

    private fun generateToDouble() {
        writer.println()
        val conversion = if (area.floatType.numBytes == 4) ".toDouble()" else ""
        writer.println("\tfun toDouble(unit: AreaUnit) = value$conversion / unit.factor")
    }

    private fun generateToString() {
        writer.println()
        writer.println("\tfun toString(unit: AreaUnit) = String.format(\"%.2f%s\", toDouble(unit), unit.abbreviation)")
        writer.println()
        writer.println("\toverride fun toString() = toString(AreaUnit.${area.displayUnit})")
    }

    private fun generateArithmetic() {
        writer.println()
        writer.println("\toverride operator fun compareTo(other: ${area.className}) = this.value.compareTo(other.value)")

        writer.println()
        writer.println("\toperator fun unaryMinus() = ${area.className}(-value)")

        writer.println()
        writer.println("\toperator fun plus(right: ${area.className}) = ${area.className}(this.value + right.value)")
        writer.println()
        writer.println("\toperator fun minus(right: ${area.className}) = ${area.className}(this.value - right.value)")

        for (typeName in arrayOf("Int", "Long", "Float", "Double")) {
            val rightSuffix = if (typeName == "Double" && area.floatType == FloatType.SinglePrecision) ".toFloat()" else ""
            writer.println()
            writer.println("\toperator fun times(right: $typeName) = ${area.className}(this.value * right$rightSuffix)")
            writer.println()
            writer.println("\toperator fun div(right: $typeName) = ${area.className}(this.value / right$rightSuffix)")
        }

        if (area.displacementClassName != null) {
            writer.println()
            writer.println("\toperator fun div(right: ${area.displacementClassName}) = ${area.displacementClassName}.METER * value / right.toDouble(DistanceUnit.METER)")
        }
        // TODO Volume class
        writer.println()
        writer.println("\toperator fun div(right: ${area.className}) = this.value / right.value")
    }

    private fun generateCompanionObject() {
        writer.println()
        writer.println("\tcompanion object {")
        val suffix = if (area.floatType.numBytes == 4) "f" else ""
        for (unit in AreaUnit.entries) {
            writer.println("\t\tval ${unit.name} = ${area.className}(${unit.factor}$suffix)")
        }
        writer.println("\t}")
    }

    private fun generateExtensionFunctions() {
        for (typeName in arrayOf("Int", "Long", "Float", "Double")) {
            writer.println()
            writer.println("operator fun $typeName.times(right: ${area.className}) = right * this")

            if (area.createNumberExtensions) {
                writer.println()
                for (unit in AreaUnit.entries) {
                    writer.println("val $typeName.${unit.abbreviation.replace("^", "")}")
                    writer.println("\tget() = ${area.className}.${unit.name} * this")
                }
            }
        }
    }

    private fun generateMathFunctions() {
        writer.println()
        writer.println("fun abs(x: ${area.className}) = ${area.className}(abs(x.value))")
        writer.println()
        writer.println("fun min(a: ${area.className}, b: ${area.className}) = ${area.className}(min(a.value, b.value))")
        writer.println()
        writer.println("fun max(a: ${area.className}, b: ${area.className}) = ${area.className}(max(a.value, b.value))")
        if (area.displacementClassName != null) {
            writer.println("fun sqrt(x: ${area.className}) = ${area.displacementClassName}.METER * sqrt(x.value)")
        }
    }
}
