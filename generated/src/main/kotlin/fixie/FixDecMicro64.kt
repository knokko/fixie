// Generated by fixie at 01-02-2024 23:28
package fixie

import java.math.BigInteger
import java.lang.Math.*

private const val RAW_ONE = 1000000L

@JvmInline
value class FixDecMicro64 private constructor(val raw: Long) : Comparable<FixDecMicro64> {

	override fun toString(): String {
		val intPart = raw / RAW_ONE
		var fractPart = (raw % RAW_ONE).toString().replace("-", "")
		while (fractPart.length < 6) fractPart = "0$fractPart"
		fractPart = ".$fractPart"
		while (fractPart.endsWith('0')) fractPart = fractPart.substring(0 until fractPart.length - 1)
		if (fractPart == ".") fractPart = ""
		val minus = if (raw < 0L && intPart == 0L) "-" else ""
		return "$minus$intPart$fractPart"
	}

	@Throws(FixedPointException::class)
	fun toInt(): Int {
		val uncheckedResult = raw / RAW_ONE
		if (uncheckedResult < Int.MIN_VALUE) throw FixedPointException("$uncheckedResult to too small")
		if (uncheckedResult > Int.MAX_VALUE) throw FixedPointException("$uncheckedResult to too large")
		return uncheckedResult.toInt()
	}

	fun toLong() = raw / RAW_ONE

	fun toFloat() = toDouble().toFloat()

	fun toDouble() = raw.toDouble() / RAW_ONE.toDouble()

	@Throws(FixedPointException::class)
	operator fun unaryMinus() = if (raw != Long.MIN_VALUE)
		FixDecMicro64(-raw) else throw FixedPointException("Can't negate MIN_VALUE")

	@Throws(FixedPointException::class)
	operator fun plus(right: FixDecMicro64): FixDecMicro64 {
		try {
			return FixDecMicro64(addExact(this.raw, right.raw))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Tried to compute $this + $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun plus(right: Int) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun plus(right: Long) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun plus(right: Float) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun plus(right: Double) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: FixDecMicro64): FixDecMicro64 {
		try {
			return FixDecMicro64(subtractExact(this.raw, right.raw))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Tried to compute $this - $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun minus(right: Int) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: Long) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: Float) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: Double) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun times(right: FixDecMicro64): FixDecMicro64 {
		val highProductBits = multiplyHigh(this.raw, right.raw)
		val lowProductBits = this.raw * right.raw
		val shouldBeNegative = (this.raw < 0) != (right.raw < 0)
		return if ((highProductBits == 0L && !shouldBeNegative && lowProductBits >= 0) || (highProductBits == -1L && shouldBeNegative && lowProductBits < 0)) {
			FixDecMicro64(lowProductBits / RAW_ONE)
		} else {
			val result = (BigInteger.valueOf(this.raw) * BigInteger.valueOf(right.raw)) / BigInteger.valueOf(RAW_ONE)
			try {
				FixDecMicro64(result.longValueExact())
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't compute $this * $right")
			}
		}
	}

	@Throws(FixedPointException::class)
	operator fun times(right: Int): FixDecMicro64 {
		try {
			return FixDecMicro64(multiplyExact(raw, right))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Can't represent $this * $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun times(right: Long): FixDecMicro64 {
		try {
			return FixDecMicro64(multiplyExact(raw, right))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Can't represent $this * $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun times(right: Float) = this * from(right)

	@Throws(FixedPointException::class)
	operator fun times(right: Double) = this * from(right)

	@Throws(FixedPointException::class)
	operator fun div(right: FixDecMicro64): FixDecMicro64 {
		val highProductBits = multiplyHigh(this.raw, RAW_ONE)
		val lowProductBits = this.raw * RAW_ONE
		return if ((highProductBits == 0L && this.raw >= 0 && lowProductBits >= 0) || (highProductBits == -1L && this.raw < 0 && lowProductBits < 0)) {
			FixDecMicro64(lowProductBits / right.raw)
		} else {
			val result = (BigInteger.valueOf(this.raw) * BigInteger.valueOf(RAW_ONE)) / BigInteger.valueOf(right.raw)
			try {
				FixDecMicro64(result.longValueExact())
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't compute $this / $right")
			}
		}
	}

	@Throws(FixedPointException::class)
	operator fun div(right: Int): FixDecMicro64 {
		if (right == 0 || (raw == Long.MIN_VALUE && right == -1)) {
			throw FixedPointException("Can't represent $this / $right")
		}
		return FixDecMicro64(raw / right)
	}

	@Throws(FixedPointException::class)
	operator fun div(right: Long): FixDecMicro64 {
		if (right == 0L || (raw == Long.MIN_VALUE && right == -1L)) {
			throw FixedPointException("Can't represent $this / $right")
		}
		return FixDecMicro64(raw / right)
	}

	@Throws(FixedPointException::class)
	operator fun div(right: Float) = this / from(right)

	@Throws(FixedPointException::class)
	operator fun div(right: Double) = this / from(right)

	override operator fun compareTo(other: FixDecMicro64) = this.raw.compareTo(other.raw)

	operator fun compareTo(other: Int) = this.compareTo(from(other))

	operator fun compareTo(other: Long) = if (other < -9223372036854) 1 else if (other > 9223372036854) -1 else this.compareTo(from(other))
	operator fun compareTo(other: Float) = if (other < -9.223372E12f) 1 else if (other > 9.223372E12f) -1 else this.compareTo(from(other))
	operator fun compareTo(other: Double) = if (other < -9.223372036854775E12) 1 else if (other > 9.223372036854775E12) -1 else this.compareTo(from(other))

	companion object {

		val ZERO = from(0)
		val ONE = from(1)

		fun raw(rawValue: Long) = FixDecMicro64(rawValue)

		fun from(value: Int) = FixDecMicro64(value.toLong() * RAW_ONE)

		@Throws(FixedPointException::class)
		fun from(value: Long): FixDecMicro64 {
			try {
				return FixDecMicro64(multiplyExact(value, RAW_ONE))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		fun from(value: Float) = from(value.toDouble())

		@Throws(FixedPointException::class)
		fun from(value: Double): FixDecMicro64 {
			val doubleValue = RAW_ONE.toDouble() * value
			if (doubleValue > Long.MAX_VALUE.toDouble() || doubleValue < Long.MIN_VALUE.toDouble()) {
				throw FixedPointException("Can't represent $value")
			}
			return FixDecMicro64(round(doubleValue))
		}
	}

	@JvmInline
	value class Array private constructor(val raw: LongArray) {

		constructor(size: Int) : this(LongArray(size))

		constructor(size: Int, initializer: (Int) -> FixDecMicro64) : this(LongArray(size) { index -> initializer(index).raw })

		val size: Int
			get() = raw.size

		operator fun get(index: Int) = FixDecMicro64(raw[index])

		operator fun set(index: Int, value: FixDecMicro64) {
			raw[index] = value.raw
		}

		fun fill(value: FixDecMicro64) {
			raw.fill(value.raw)
		}
	}
}

@Throws(FixedPointException::class)
operator fun Int.plus(right: FixDecMicro64) = FixDecMicro64.from(this) + right

@Throws(FixedPointException::class)
operator fun Long.plus(right: FixDecMicro64) = FixDecMicro64.from(this) + right

@Throws(FixedPointException::class)
operator fun Float.plus(right: FixDecMicro64) = FixDecMicro64.from(this) + right

@Throws(FixedPointException::class)
operator fun Double.plus(right: FixDecMicro64) = FixDecMicro64.from(this) + right

@Throws(FixedPointException::class)
operator fun Int.minus(right: FixDecMicro64) = FixDecMicro64.from(this) - right

@Throws(FixedPointException::class)
operator fun Long.minus(right: FixDecMicro64) = FixDecMicro64.from(this) - right

@Throws(FixedPointException::class)
operator fun Float.minus(right: FixDecMicro64) = FixDecMicro64.from(this) - right

@Throws(FixedPointException::class)
operator fun Double.minus(right: FixDecMicro64) = FixDecMicro64.from(this) - right

@Throws(FixedPointException::class)
operator fun Int.times(right: FixDecMicro64) = right * this

@Throws(FixedPointException::class)
operator fun Long.times(right: FixDecMicro64) = right * this

@Throws(FixedPointException::class)
operator fun Float.times(right: FixDecMicro64) = right * this

@Throws(FixedPointException::class)
operator fun Double.times(right: FixDecMicro64) = right * this

@Throws(FixedPointException::class)
operator fun Int.div(right: FixDecMicro64) = FixDecMicro64.from(this) / right

@Throws(FixedPointException::class)
operator fun Long.div(right: FixDecMicro64) = FixDecMicro64.from(this) / right

@Throws(FixedPointException::class)
operator fun Float.div(right: FixDecMicro64) = FixDecMicro64.from(this) / right

@Throws(FixedPointException::class)
operator fun Double.div(right: FixDecMicro64) = FixDecMicro64.from(this) / right

operator fun Int.compareTo(right: FixDecMicro64) = FixDecMicro64.from(this).compareTo(right)

operator fun Long.compareTo(right: FixDecMicro64) = FixDecMicro64.from(this).compareTo(right)

operator fun Float.compareTo(right: FixDecMicro64) = FixDecMicro64.from(this).compareTo(right)

operator fun Double.compareTo(right: FixDecMicro64) = FixDecMicro64.from(this).compareTo(right)

@Throws(FixedPointException::class)
fun abs(value: FixDecMicro64) = if (value.raw != Long.MIN_VALUE) FixDecMicro64.raw(kotlin.math.abs(value.raw))
		else throw FixedPointException("Can't represent abs of min value")

fun min(a: FixDecMicro64, b: FixDecMicro64) = FixDecMicro64.raw(kotlin.math.min(a.raw, b.raw))

fun max(a: FixDecMicro64, b: FixDecMicro64) = FixDecMicro64.raw(kotlin.math.max(a.raw, b.raw))
