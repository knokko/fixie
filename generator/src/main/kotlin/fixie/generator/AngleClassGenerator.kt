package fixie.generator

import fixie.AngleUnit
import fixie.SpeedUnit
import java.io.PrintWriter
import java.math.BigDecimal
import java.math.BigInteger
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*

class AngleClassGenerator(
        private val writer: PrintWriter,
        private val angle: AngleClass
) {

    init {
        if (angle.number.checkOverflow) {
            throw IllegalArgumentException("Number type must not check overflow because angle additions and subtractions " +
                    "rely on overflow of the number type")
        }
    }

    fun generate() {
        generateClassPrefix()
        generateToDouble()
        generateToString()
        generateArithmetic()
        generateCompanionObject()
        writer.println("}")
        generateExtensionFunctions()
        generateMathFunctions()
    }

    private fun generateClassPrefix() {
        val currentTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm"))
        writer.println("// Generated by fixie at $currentTime")
        writer.println("package fixie")
        writer.println()
        writer.println("import java.text.DecimalFormat")
        writer.println("import java.util.Locale")
        writer.println("import kotlin.math.*")
        writer.println()
        writer.println("@JvmInline")
        writer.print("value class ${angle.className} internal constructor(val value: ${angle.number.className}) ")
        if (angle.allowComparisons) writer.print(": Comparable<${angle.className}> ")
        writer.println("{")
    }

    private fun generateToDouble() {
        writer.println()
        writer.println("\tfun toDouble(unit: AngleUnit) = when(unit) {")
        for (unit in AngleUnit.entries) {
            val maxValue = if (angle.number.internalType.signed) 0.5 * unit.maxValue else unit.maxValue
            writer.println("\t\tAngleUnit.$unit -> ${maxValue / angle.number.internalType.getMaxValue().toDouble()} * value.raw.toDouble()")
        }
        writer.println("\t}")
    }

    private fun generateToString() {
        writer.println()
        writer.println("\toverride fun toString() = toString(AngleUnit.${angle.displayUnit}, 1)")
        writer.println()
        writer.println("\tfun toString(unit: AngleUnit, maximumFractionDigits: Int): String {")
        writer.println("\t\tval format = DecimalFormat.getInstance(Locale.ROOT)")
        writer.println("\t\tformat.maximumFractionDigits = maximumFractionDigits")
        writer.println("\t\treturn format.format(toDouble(unit)) + unit.suffix")
        writer.println("\t}")
    }

    private fun generateArithmetic() {
        if (angle.allowComparisons) {
            writer.println()
            writer.println("\toverride operator fun compareTo(other: ${angle.className}) = this.value.compareTo(other.value)")
        }

        writer.println()
        if (angle.number.internalType.signed) {
            writer.println("\toperator fun unaryMinus() = ${angle.className}(-this.value)")
        } else {
            writer.println("\toperator fun unaryMinus() = ${angle.className}(${angle.number.className}.ZERO) - this")
        }

        writer.println()
        writer.println("\toperator fun plus(right: ${angle.className}) = ${angle.className}(this.value + right.value)")
        writer.println()
        writer.println("\toperator fun minus(right: ${angle.className}) = ${angle.className}(this.value - right.value)")

        if (angle.allowDivisionAndMultiplication) {
            for (typeName in arrayOf("Int", "Float", "Double", angle.number.className)) {
                writer.println()
                writer.println("\toperator fun times(right: $typeName) = ${angle.className}(this.value * right)")
                writer.println()
                writer.println("\toperator fun div(right: $typeName) = ${angle.className}(this.value / right)")
            }

            writer.println()
            writer.println("\toperator fun div(right: ${angle.className}) = this.value / right.value")
        }
    }

    private fun generateCompanionObject() {
        writer.println()
        writer.println("\tcompanion object {")
        writer.println()
        writer.println("\t\tfun raw(value: ${angle.number.internalType}) = ${angle.className}(${angle.number.className}.raw(value))")

        for (unit in AngleUnit.entries) {

            val maxValue = if (angle.number.internalType.signed) 0.5 * unit.maxValue else unit.maxValue
            val factor = angle.number.internalType.getMaxValue().toDouble() / maxValue
            val postConversion = ".to${angle.number.internalType}()"

            writer.println()
            writer.println("\t\tfun ${unit.name.lowercase(Locale.ROOT)}(value: Double) = if (value >= 0.0) raw(round((value % 360.0) * $factor)$postConversion)")
            writer.println("\t\telse raw(round((value % 360.0 + 360.0) * $factor)$postConversion)")
            for (typeName in arrayOf("Int", "Float", angle.number.className)) {
                writer.println()
                writer.println("\t\tfun ${unit.name.lowercase(Locale.ROOT)}(value: $typeName) = degrees(value.toDouble())")
            }
        }

        writer.println("\t}")
    }

    private fun generateExtensionFunctions() {
        for (typeName in arrayOf("Int", "Float", "Double", angle.number.className)) {
            if (angle.allowDivisionAndMultiplication) {
                writer.println()
                writer.println("operator fun $typeName.times(right: ${angle.className}) = right * this")
            }

            if (angle.createNumberExtensions) {
                for (unit in AngleUnit.entries) {
                    writer.println()
                    writer.println("val $typeName.${unit.name.lowercase(Locale.ROOT)}")
                    writer.println("\tget() = ${angle.className}.${unit.name.lowercase(Locale.ROOT)}(this)")
                }
            }
        }
    }

    private fun generateMathFunctions() {
        if (angle.number.internalType.signed) {
            writer.println()
            writer.println("fun abs(x: ${angle.className}) = ${angle.className}(abs(x.value))")
        }

        if (angle.allowComparisons) {
            writer.println()
            writer.println("fun min(a: ${angle.className}, b: ${angle.className}) = ${angle.className}(min(a.value, b.value))")
            writer.println()
            writer.println("fun max(a: ${angle.className}, b: ${angle.className}) = ${angle.className}(max(a.value, b.value))")
        }

        for (functionName in arrayOf("sin", "cos", "tan")) {
            writer.println()
            writer.println("fun $functionName(x: ${angle.className}) = $functionName(x.toDouble(AngleUnit.RADIANS))")
        }
    }
}
